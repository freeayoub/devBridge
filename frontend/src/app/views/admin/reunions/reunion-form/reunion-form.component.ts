import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ReunionService } from 'src/app/services/reunion.service';
import { PlanningService } from 'src/app/services/planning.service';
import { ActivatedRoute, Router } from '@angular/router';
import { Reunion } from 'src/app/models/reunion.model';
import { Planning } from 'src/app/models/planning.model';
import { AuthuserService } from 'src/app/services/authuser.service';
import {Observable} from "rxjs";
import {User} from "@app/models/user.model";
import {DataService} from "@app/services/data.service";
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { ToastService } from 'src/app/services/toast.service';

@Component({
  selector: 'app-reunion-form',
  templateUrl: './reunion-form.component.html',
  styleUrls: ['./reunion-form.component.css']
})
export class ReunionFormComponent implements OnInit {
  reunionForm: FormGroup;
  plannings: Planning[] = [];
  users$: Observable<User[]>;
  loading = true;
  isSubmitting = false;
  error: any = null;
  successMessage: string | null = null;
  isEditMode = false;
  currentReunionId: string | null = null;
  planningIdFromUrl: string | null = null;
  selectedPlanning: Planning | null = null;
  lienVisioError: string | null = null;
  isCheckingLienVisio = false;

  constructor(
    private fb: FormBuilder,
    private reunionService: ReunionService,
    private planningService: PlanningService,
    private userService: DataService,
    private route: ActivatedRoute,
    private router: Router,
    private authService: AuthuserService,
    private toastService: ToastService
  ) {
    this.reunionForm = this.fb.group({
      titre: ['', Validators.required],
      description: [''],
      date: ['', Validators.required],
      heureDebut: ['', Validators.required],
      heureFin: ['', Validators.required],
      lieu: [''],
      lienVisio: [''],
      planning: ['', Validators.required],
      participants: [[]]
    });


    this.users$ = this.userService.getAllUsers();
  }

  ngOnInit(): void {
    this.loadPlannings();
    this.checkEditMode();
    this.checkPlanningParam();
    this.setupLienVisioValidation();
  }

  checkEditMode(): void {
    const reunionId = this.route.snapshot.paramMap.get('id');
    if (reunionId) {
      this.isEditMode = true;
      this.currentReunionId = reunionId;
      this.loadReunion(reunionId);
    }
  }

  loadPlannings(): void {
    const userId = this.authService.getCurrentUserId();
    if (!userId) return;

    this.planningService.getPlanningsByUser(userId).subscribe({
      next: (response:any) => {
        this.plannings = response.plannings || [];
        console.log('üîç Plannings charg√©s:', this.plannings);
        console.log('üîç Premier planning:', this.plannings[0]);
      },
      error: (err) => {
        this.error = err;
        console.error('‚ùå Erreur chargement plannings:', err);
      }
    });
  }

  loadReunion(id: string): void {
    this.reunionService.getReunionById(id).subscribe({
      next: (reunion) => {
        this.reunionForm.patchValue({
          titre: reunion.titre,
          description: reunion.description,
          dateDebut: this.formatDateForInput(reunion.dateDebut),
          dateFin: this.formatDateForInput(reunion.dateFin),
          lieu: reunion.lieu,
          lienVisio: reunion.lienVisio,
          planningId: reunion.planningId,
          participants: reunion.participants
        });
        this.loading = false;
      },
      error: (err) => {
        this.error = err;
        this.loading = false;
      }
    });
  }

  formatDateForInput(date: Date | string): string {
    return new Date(date).toISOString().slice(0, 16); // yyyy-MM-ddTHH:mm
  }

  checkPlanningParam(): void {
    const planningId = this.route.snapshot.queryParamMap.get('planningId');
    if (planningId) {
      this.planningIdFromUrl = planningId;

      // Si un ID de planning est fourni dans les param√®tres de requ√™te, le s√©lectionner automatiquement
      this.reunionForm.patchValue({
        planning: planningId
      });

      // R√©cup√©rer les d√©tails du planning pour l'affichage
      this.planningService.getPlanningById(planningId).subscribe({
        next: (response: any) => {
          this.selectedPlanning = response.planning;
          // Ajouter le planning √† la liste locale pour la validation
          if (this.selectedPlanning && !this.plannings.find(p => p._id === planningId)) {
            this.plannings.push(this.selectedPlanning);
            console.log('‚úÖ Planning ajout√© √† la liste locale pour validation:', this.selectedPlanning);
          }
        },
        error: (err) => {
          console.error('Erreur lors de la r√©cup√©ration du planning:', err);
          this.toastService.error(
            'Planning introuvable',
            'Le planning s√©lectionn√© n\'existe pas ou vous n\'avez pas les permissions pour y acc√©der'
          );
        }
      });
    }
  }

  onSubmit(): void {
    if (this.reunionForm.invalid || !this.canSubmit()) {
      this.toastService.warning(
        'Formulaire invalide',
        'Veuillez corriger les erreurs avant de soumettre le formulaire'
      );
      return;
    }

    // Validation de la date par rapport au planning
    if (!this.validateDateInPlanningRange()) {
      return;
    }

    this.isSubmitting = true;
    this.error = null;
    this.successMessage = null;
    const formValue = this.reunionForm.value;

    const date = formValue.date; // already in yyyy-MM-dd format from input[type=date]
    const heureDebut = formValue.heureDebut; // already in HH:mm format from input[type=time]
    const heureFin = formValue.heureFin;

    const reunionData: any = {
      titre: formValue.titre,
      description: formValue.description,
      date: date,
      heureDebut: heureDebut,
      heureFin: heureFin,
      lieu: formValue.lieu,
      lienVisio: formValue.lienVisio,
      planning: formValue.planning,
      participants: formValue.participants || []
    };

    console.log('üîç Donn√©es de la r√©union √† envoyer:', reunionData);
    console.log('üîç Planning ID s√©lectionn√©:', formValue.planning);
    console.log('üîç Type du planning ID:', typeof formValue.planning);
    console.log('üîç Plannings disponibles:', this.plannings);

    this.reunionService.createReunion(reunionData).subscribe({
      next: () => {
        this.isSubmitting = false;

        this.toastService.success(
          'R√©union cr√©√©e',
          'La r√©union a √©t√© cr√©√©e avec succ√®s'
        );

        // R√©initialiser le formulaire pour permettre la cr√©ation d'une nouvelle r√©union
        this.resetForm();

        // Redirection imm√©diate
        this.router.navigate(['/reunions']);
      },
      error: (err) => {
        this.isSubmitting = false;
        console.error('Erreur lors de la cr√©ation de la r√©union:', err);

        if (err.status === 403) {
          this.toastService.accessDenied('cr√©er une r√©union', err.status);
        } else if (err.status === 401) {
          this.toastService.error(
            'Non autoris√©',
            'Vous devez √™tre connect√© pour cr√©er une r√©union'
          );
        } else {
          const errorMessage = err.error?.message || 'Erreur lors de la cr√©ation de la r√©union';
          this.toastService.error(
            'Erreur de cr√©ation',
            errorMessage,
            8000
          );
        }
      }
    });
  }

  resetForm(): void {
    // Reset the form to its initial state
    this.reunionForm.reset({
      titre: '',
      description: '',
      date: '',
      heureDebut: '',
      heureFin: '',
      lieu: '',
      lienVisio: '',
      planning: '',
      participants: []
    });

    // Mark the form as pristine and untouched to reset validation states
    this.reunionForm.markAsPristine();
    this.reunionForm.markAsUntouched();
  }


  goReunion(): void {
    this.router.navigate(['/reunions']);
  }

  /**
   * Configure la validation en temps r√©el du lien visio avec debounce
   */
  setupLienVisioValidation(): void {
    this.reunionForm.get('lienVisio')?.valueChanges
      .pipe(
        debounceTime(500), // Attendre 500ms apr√®s la derni√®re saisie
        distinctUntilChanged() // Ne d√©clencher que si la valeur a chang√©
      )
      .subscribe(value => {
        if (value && value.trim() !== '') {
          this.checkLienVisioUniqueness(value.trim());
        } else {
          this.lienVisioError = null;
        }
      });
  }

  /**
   * V√©rifie l'unicit√© du lien visio
   * @param lienVisio Le lien √† v√©rifier
   */
  checkLienVisioUniqueness(lienVisio: string): void {
    if (!lienVisio || lienVisio.trim() === '') {
      this.lienVisioError = null;
      return;
    }

    this.isCheckingLienVisio = true;
    this.lienVisioError = null;

    // Utiliser la nouvelle route d√©di√©e pour v√©rifier l'unicit√©
    this.reunionService.checkLienVisioUniqueness(lienVisio, this.currentReunionId || undefined).subscribe({
      next: (response) => {
        this.isCheckingLienVisio = false;

        if (response.success && !response.isUnique) {
          this.lienVisioError = `Ce lien est d√©j√† utilis√© par la r√©union "${response.conflictWith?.titre}"`;
        } else {
          this.lienVisioError = null;
        }
      },
      error: (error) => {
        this.isCheckingLienVisio = false;
        console.error('Erreur lors de la v√©rification du lien visio:', error);
        this.lienVisioError = 'Erreur lors de la v√©rification du lien';
      }
    });
  }

  /**
   * V√©rifie si le formulaire peut √™tre soumis
   */
  canSubmit(): boolean {
    return this.reunionForm.valid && !this.lienVisioError && !this.isCheckingLienVisio;
  }

  /**
   * Valide que la date de la r√©union est dans l'intervalle du planning s√©lectionn√©
   */
  validateDateInPlanningRange(): boolean {
    const formValue = this.reunionForm.value;
    const reunionDate = formValue.date;
    const planningId = formValue.planning;

    if (!reunionDate || !planningId) {
      return true; // Si pas de date ou planning, laisser la validation backend g√©rer
    }

    // Chercher d'abord dans la liste locale, puis dans selectedPlanning
    let selectedPlanning = this.plannings.find(p => p._id === planningId);

    if (!selectedPlanning && this.selectedPlanning && this.selectedPlanning._id === planningId) {
      selectedPlanning = this.selectedPlanning;
    }

    if (!selectedPlanning) {
      console.warn('‚ö†Ô∏è Planning non trouv√© pour validation:', planningId);
      console.log('üìã Plannings disponibles:', this.plannings.map(p => ({ id: p._id, titre: p.titre })));
      console.log('üéØ Selected planning:', this.selectedPlanning);

      // Ne pas bloquer si le planning n'est pas trouv√© - laisser le backend valider
      return true;
    }

    // Convertir les dates pour comparaison
    const reunionDateObj = new Date(reunionDate);
    const planningDateDebut = new Date(selectedPlanning.dateDebut);
    const planningDateFin = new Date(selectedPlanning.dateFin);

    // Comparer seulement les dates (sans les heures)
    reunionDateObj.setHours(0, 0, 0, 0);
    planningDateDebut.setHours(0, 0, 0, 0);
    planningDateFin.setHours(0, 0, 0, 0);

    if (reunionDateObj < planningDateDebut || reunionDateObj > planningDateFin) {
      this.toastService.error(
        'Date invalide',
        `La date de la r√©union doit √™tre comprise entre le ${planningDateDebut.toLocaleDateString('fr-FR')} et le ${planningDateFin.toLocaleDateString('fr-FR')} (p√©riode du planning "${selectedPlanning.titre}")`,
        10000
      );
      return false;
    }

    return true;
  }
}